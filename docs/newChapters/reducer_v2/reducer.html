<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  summary {
    height: 1em;
    width: 100%;
  }
  details[open] {
    width: 100%;
    height: calc(100vh - 2em);
  }
  #request {
    width: 45%;
    float: left;
    height: calc(100% - 2em);
  }
  #env {
    width: 45%;
    float: left;
    height: calc(100% - 2em);
  }
  #editor {
    width: 100%;
    height: calc(100% - 2em);
  }
  #viewer {
    width: 100vw;
    height: calc(100% - 2em);
  }
</style>
<details>
  <summary>Input data</summary>
  <textarea name="request" id="request"></textarea>
  <textarea name="env" id="env"></textarea>
  <textarea name="fullState" id="fullState" hidden></textarea>
  <textarea name="trace" id="trace" hidden></textarea>
</details>
<details>
  <summary id="editorHeader">Editor.
    <a href="#test1.js">test1.js</a>/
    <a href="#helloSunshine.js">helloSunshine.js</a>/
    <a href="#eyJmdW5jdGlvbnMiOnsiW1wiZ2V0VXJsXCIsXCJoZWxsb1N1bnNoaW5lXCJdIjoiZGF0YTp0ZXh0L2phdmFzY3JpcHQsXFxcbmV4cG9ydCBmdW5jdGlvbiBnZXRVcmwoYSkge1xcXG4gIHJldHVybiBhLnVybDtcXFxufVxcXG5cXFxuZXhwb3J0IGZ1bmN0aW9uIGhlbGxvU3Vuc2hpbmUoYSkge1xcXG4gIHJldHVybiAnSGVsbG9TdW5zaGluZTogJyArIGE7XFxcbn1cXFxuXFxcbiJ9LCJhY3Rpb25zIjpbW1sicmVxdWVzdCJdLCJnZXRVcmwiLCJ1cmwiXSxbWyJ1cmwiXSwiaGVsbG9TdW5zaGluZSIsInJlc3BvbnNlIl1dLCJzdGF0ZSI6eyJyZXF1ZXN0Ijp7InVybCI6Imh0dHBzOi8vdmcubm8vZXJyb3IifSwiZW52Ijp7ImNhY2hlMyI6eyIxIjp7InN1Y2Nlc3MiOiJzdW5zaGlueSBkYXkifX0sIl9kZWJ1ZyI6dHJ1ZSwiX211dGF0aW9uQ2hlY2siOnRydWV9fX0">helloSunshine</a>
  </summary>
  <textarea name="editor" id="editor"></textarea>
</details>
<details>
  <summary onclick="event.target === this && event.preventDefault()">
    <input id="debug" type="checkbox"> add debugger in devtools. ///////
    <input id="mutations" type="checkbox"> doublecheck mutations in actions.
    <button id="run" autofocus>Run!</button>
  </summary>
  <h3>Below comes warnings:</h3>
  <pre id="warnings"></pre>
  <h3>Below comes auto generated unit tests:</h3>
  <pre id="units"></pre>
  <iframe id="runner" hidden></iframe>
</details>
<details open>
  <summary>View debugger</summary>
  <iframe id="viewer" src="debug.html"></iframe>
</details>
<script>

  function printEditableFunction([name, body]) {
    if (body.startsWith('data:text/javascript,'))
      return body.substr(21).replaceAll('\\\n', '\n').replaceAll('\"', '"') + '\n';
    name = name[0] === '[' ? JSON.parse(name).join(', ') : name;
    return `import {${name}} from "${body}";`;
  }

  function editorText(actions, functions) {
    const functionsText = Object.entries(functions).map(printEditableFunction).join('\n');
    const actionsText = `const actions = ${JSON.stringify(actions, null, 2)};`
    return `${functionsText}\n${actionsText}`;
  }

  function render() {
    try {
      const data = location.hash.substr(1);
      const {actions, functions, trace, state} = JSON.parse(atob(data));

      document.querySelector("#editor").value = editorText(actions, functions);

      document.querySelector("#trace").value = trace;

      const request = JSON.stringify(state.request, null, 2);
      const env = JSON.stringify(state.env, null, 2);
      const fullState = JSON.stringify(state, null, 2);
      document.querySelector("#request").value = request;
      document.querySelector("#env").value = env;
      document.querySelector("#fullState").value = fullState;
      document.querySelector("#mutations").checked = !!state?.env?._debug;
      document.querySelector("#debug").checked = !!state?.env?._mutationCheck;

      document.querySelector("#viewer").src = 'debug.html#' + data;
    } catch (err) {
      console.error('render failed: ' + err);
    }
  }

  addEventListener('hashchange', render);
  render();

  //todo only encrypting all the functions in one big bite here..
  //todo should make these entries individual per function to much better support automatic unit tests.
  //todo and ml
  //todo and smart ide that might based on a series of unit tests suggest functions that you can replace your functions with.
  function getCodeFromEditor(text) {
    let [functions, actions] = text.split('const listOfActions =');
    actions = JSON.parse(actions.substr(0, actions.length - 1));
    const keys = JSON.stringify(actions.map(([p, fun]) => fun));
    functionsList = {};
    functionsList[keys] = "data:text/javascript,\\\n" + functions.replaceAll('\n', '\\\n').replaceAll('"', '\\"');
    return {functions: functionsList, actions};
  }

  //todo this method is what runs when something changes in the editor
  function updateHash() {
    const request = JSON.parse(document.querySelector("#request").value);
    const env = JSON.parse(document.querySelector("#env").value);
    const fullState = JSON.parse(document.querySelector("#fullState").value);
    const _mutationCheck = document.querySelector("#mutations").checked;
    const _debug = document.querySelector("#debug").checked;
    const codeText = document.querySelector("#editor").value.trim();
    const trace = document.querySelector("#trace").value;

    const {functions, actions} = getCodeFromEditor(codeText);
    const state = Object.assign(fullState, {request, env}, {env: {_debug, _mutationCheck}});
    const data = {actions, functions, state, trace};
    const hash = btoa(JSON.stringify(data));
    location.hash = "#" + hash;
  }

  document.querySelector("#run").addEventListener('click', function () {
    document.querySelector('#runner').src = 'runner.html' + location.hash;
  });

  addEventListener('message', e => location.hash = '#' + e.data);
</script>

<pre hidden>
todo the purpose of the reducer pattern is to make the logic more declarative.

e is the state, but because it is async, we must decorate the state, and not replace it.
reducer is a pure(-ish) function. It can get data from outside, and it can use only the data in the incoming state.
errors needs to be masked on a reducer/reducer basis.

the properties of the context object is *both* a property *and* a state marker at the same time.
the property is both a point in space and a point in time.

when more than one promise leads to a property, then first come first serve.
This way, reducers can race to reach a point in space/time, and only the first reducer will fill the space/win the race.
a reducer will not start until all its marked dependencies are fulfilled.

This is a time/machine, as much as it is a state.
</pre>