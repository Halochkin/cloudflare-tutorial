<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  summary {
    height: 1em;
    width: 100%;
  }
  details[open] {
    width: 100%;
    height: calc(100vh - 2em);
  }
  #request {
    width: 45%;
    float: left;
    height: calc(100% - 2em);
  }
  #globals {
    width: 45%;
    float: left;
    height: calc(100% - 2em);
  }
  #editor {
    width: 100%;
    height: calc(100% - 2em);
  }
  #viewer {
    width: 100vw;
    height: calc(100% - 2em);
  }
</style>
<details>
  <summary>Input data</summary>
  <textarea name="request" id="request">
{
  "url": "https://vg.no/error"
}
  </textarea>
  <textarea name="globals" id="globals">
{
    "cache3": {
      "1": {
         "success": "sunshiny day"
      }
    }
}
  </textarea>
</details>
<details>
  <summary>Editor.
    <a href="#test1.js">test1.js</a>
    <a href="#helloSunshine.js">helloSunshine.js</a>/
  </summary>
  <textarea name="editor" id="editor"></textarea>
</details>
<details>
  <summary onclick="event.target === this && event.preventDefault()">
    <input id="debug" type="checkbox"> add debugger in devtools. ///////
    <input id="mutations" type="checkbox"> doublecheck mutations in actions.
    <button id="run" autofocus>Run!</button>
  </summary>
  <h3>Below comes warnings:</h3>
  <pre id="warnings"></pre>
  <h3>Below comes auto generated unit tests:</h3>
  <pre id="units"></pre>
  <iframe id="runner" hidden></iframe>
</details>
<details open>
  <summary>View debugger</summary>
  <iframe id="viewer" src="debug.html"></iframe>
</details>
<script>
  const editor = document.querySelector('#editor');

  async function updateEditor() {
    const test1Script = await fetch('tests/' + location.hash.substr(1));
    editor.value = await test1Script.text();
  }

  function encodeInstanceState(actions, functions, startState, debug, mutationCheck) {
    return btoa(JSON.stringify({actions, functions, startState, runnerSettings: {debug, mutationCheck}}));
  }

  //todo only encrypting all the functions in one big bite here..
  //todo should make these entries individual per function to much better support automatic unit tests.
  //todo and ml
  //todo and smart ide that might based on a series of unit tests suggest functions that you can replace your functions with.
  function getCodeFromEditor() {
    let [functions, actions] = editor.value.trim().split('const listOfActions =');
    actions = JSON.parse(actions.substr(0, actions.length - 1));
    const keys = JSON.stringify(actions.map(([p, fun]) => fun));
    functionsList = {};
    functionsList[keys] = "data:text/javascript,\\\n" + functions.replaceAll('\n', '\\\n').replaceAll('"', '\\"');
    return {functions: functionsList, actions};
  }

  (function () {
    //init
    updateEditor();
    window.addEventListener('hashchange', updateEditor);
    document.querySelector("#run").addEventListener('click', runInIframe);

    function runInIframe() {
      document.querySelector("#warnings").innerText = '';
      const doDebug = document.querySelector('#debug').checked;
      const doMutationsCheck = document.querySelector('#mutations').checked;
      const request = JSON.parse(document.querySelector("#request").value);
      const env = JSON.parse(document.querySelector("#globals").value);
      let {functions, actions} = getCodeFromEditor();
      const hash = encodeInstanceState(actions, functions, {request, env}, doDebug, doMutationsCheck);
      document.querySelector('#runner').src = 'runner.html#' + hash;
    }

    function updateViewer(e) {
      debugger
      document.querySelector('#viewer').src = 'debug.html#' + e.data;
    }

    addEventListener('message', updateViewer);
  })();
</script>

<pre hidden>
todo the purpose of the reducer pattern is to make the logic more declarative.

e is the state, but because it is async, we must decorate the state, and not replace it.
reducer is a pure(-ish) function. It can get data from outside, and it can use only the data in the incoming state.
errors needs to be masked on a reducer/reducer basis.

the properties of the context object is *both* a property *and* a state marker at the same time.
the property is both a point in space and a point in time.

when more than one promise leads to a property, then first come first serve.
This way, reducers can race to reach a point in space/time, and only the first reducer will fill the space/win the race.
a reducer will not start until all its marked dependencies are fulfilled.

This is a time/machine, as much as it is a state.
</pre>