<script type="module">
  import {handleResponse, stateMachine} from "./ResponseRace.js";
  import {compile} from "./compiler.js";

  function debug(frame) {
    frame.functions = window.functions;
    console.log(frame)
    const msg = frameToString(frame);
    window.parent.postMessage(msg, '*');
  }

  function frameToString({actions, functions, state: context, trace: sequence}) {
    actions = actions.map(([id, params, fun, output, error]) => [params.map(p => p instanceof Object ? p.op + p.key : typeof (p) === 'string' ? JSON.stringify(p) : p), fun.name, output, error]);
    const state = {};
    for (let key in context)
      state[key] = context[key] === undefined ? null : context[key];
    return btoa(JSON.stringify({actions, functions, trace: sequence, state: state}));
    //todo ugly hack to put the functions back into the stack trace.
  }

  let previous;

  function checkMutations(frame) {
    if (!previous) {
      previous = {};
      frame.state._mutations = {};
      for (let key in frame.state)
        previous[key] = JSON.stringify(frame.state[key]);
      return;
    }
    const res = {}, diff = [];
    for (let key in frame.state) {
      res[key] = JSON.stringify(frame.state[key]);
      previous[key] !== res[key] && (diff.push([key, previous[key], res[key]]));
    }
    previous = res;                      //todo rename sequence to trace
    if (diff.length > 1) {               //todo this is untested!! todo don't exactly know how to update the sequence here..
      const i = Object.keys(frame.state._mutations).length;
      frame.state._mutations[i] = diff;
      frame.sequence += '_M' + i;
    }
    return diff;
  }

  window.debug = debug;
  window.checkMutations = checkMutations;

  //adding mock methods for the fetch event
  addEventListener('fetch', e => {
    e.passThroughOnException = () => console.log('passThroughOnException.');
    e.waitUntil = async data => console.log('waitUntil: ', await data);
    e.respondWith = async data => console.log('respondWith: ', await data);

    const {response, observer} = stateMachine(window.actions, e.state, window.cbs);
    handleResponse(e, response, observer);
  });

  async function loadFunctions(functions) {
    const res = {};
    for (let rawkey in functions) {
      const importUrl = functions[rawkey];
      let declarations = await import(importUrl.replaceAll('\\\n', '\n').replaceAll('\"', '"'));
      for (let key of JSON.parse(rawkey))
        res[key] = declarations[key];
    }
    return res;
  }

  function linkFunctionState(state, functions) {
    if (!state._functions)
      return;
    for (let funName in state._functions) {
      if (!(funName in functions))
        continue;                              //setting test values on a function that is not loaded.
      const funSettings = state._functions[funName];
      for (let [setting, startValue] of Object.entries(funSettings)) {
        startValue !== undefined && (functions[funName][setting] = startValue);
        state._functions[funName][setting] = functions[funName][setting];
      }
    }
  }

  (async function init() {
    let {functions, actions, state} = JSON.parse(atob(location.hash.substr(1)));
    window.functions = functions;
    const declarations = await loadFunctions(functions);
    actions = compile(actions);
    actions.forEach(action => action[2] = declarations[action[2]]);  //link up functions in actions
    window.actions = actions;

    //update environment the settings.
    linkFunctionState(state, declarations);
    window.cbs = [];
    state?.env?._debug && window.cbs.push(debug);
    state?.env?._mutationCheck && window.cbs.push(checkMutations);

    dispatchEvent(Object.assign(new Event('fetch'), {state}));
  })();
</script>