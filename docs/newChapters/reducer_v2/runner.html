<script id="dynamo" type="module"></script>

<script type="module">import {handleResponse, stateMachine} from "./ResponseRace.js";

function debug(frame) {
  const msg = frameToString(frame);
  console.log(msg);
  window.parent.postMessage(msg, '*');
}

function frameToString({actions, variables: context, sequence}) {
  actions = actions.map(([id, params, fun, output, error]) => [params.map(p => p instanceof Object ? p.op + p.key : typeof (p) === 'string' ? JSON.stringify(p) : p), fun.name, output, error]);
  const variables = {};
  for (let key in context)
    variables[key] = context[key] === undefined ? null : context[key];
  return btoa(JSON.stringify({actions, functions: window.functions, trace: sequence, state: variables}));
  //todo ugly hack to put the functions back into the stack trace.
}

let previous;

function checkMutations(frame) {
  if (!previous) {
    previous = {};
    frame.variables._mutations = {};
    for (let key in frame.variables)
      previous[key] = JSON.stringify(frame.variables[key]);
    return;
  }
  const res = {}, diff = [];
  for (let key in frame.variables) {
    res[key] = JSON.stringify(frame.variables[key]);
    previous[key] !== res[key] && (diff.push([key, previous[key], res[key]]));
  }
  previous = res;                      //todo rename sequence to trace
  if (diff.length > 1) {               //todo this is untested!! todo don't exactly know how to update the sequence here..
    const i = Object.keys(frame.variables._mutations).length;
    frame.variables._mutations[i] = diff;
    frame.sequence += '_M' + i;
  }
  return diff;
}

window.debug = debug;
window.checkMutations = checkMutations;

//adding mock methods for the fetch event
addEventListener('fetch', e => {
  e.passThroughOnException = () => console.log('passThroughOnException.');
  e.waitUntil = async data => console.log('waitUntil: ', await data);
  e.respondWith = async data => console.log('respondWith: ', await data);
});

function printParam(p) {
  if (p instanceof Object)
    return `"${p.op}${p.key}"`;
  if (typeof p === 'string')
    return JSON.stringify(p);
  return p;
}

function printAction(action) {
  const [params, fun, output, error] = action;
  return `[[${params.map(printParam).join(', ')}], ${fun}, '${output}', '${error}']`;
}

function printFunction([key, value]) {
  if (key[0] === '[')
    key = JSON.parse(key).join(', ');
  return `import {${key}} from "${value}";`;
}

function decodeInstanceState(txt) {
  return JSON.parse(atob(txt));
}

function printFunctions(functions) {
  return Object.entries(functions).map(printFunction).join('\\n')
}

addEventListener('fetch', e => {
  console.log(e);
  const {response, observer} = stateMachine(window.actions, e.startState, window.cbs);
  handleResponse(e, response, observer);
});

(function init() {
  const dynamo = document.querySelector("#dynamo");
  const {functions, actions, state} = decodeInstanceState(location.hash.substr(1));
  const textContent = printCode(functions, actions, state, state?.env?._debug, state?.env?._mutationCheck);
  dynamo.textContent = textContent;
})();

function printCode(functions, actions, state, debug, mutationsCheck) {
  return `
import {compile} from "./compiler.js";

window.functions = ${JSON.stringify(functions, null, 2)};

${printFunctions(functions)}

const actions = [
  ${actions.map(printAction).join(',\n  ')}
];
window.actions = compile(actions);

window.cbs = [${((mutationsCheck ? 'checkMutations, ' : '') + (debug ? 'debug, ' : ''))}];

const startState = ${JSON.stringify(state, null, 2)};

dispatchEvent(Object.assign(new Event('fetch'), {startState}));`;
}

</script>