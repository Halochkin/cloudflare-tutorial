

<script>
  function idToPosition(actions, states, res = {}, y = 0) {
    //states which is an output in the actions
    const notReadyStates = states.filter(s => actions.find(([i, p, f, r, e]) => r === s || e === s));
    //actions which after ready states are removed, still lacks a required parameter
    const notReadyActions = actions.filter(([_, params]) => params.filter(p => p[0] !== '*').find(p => notReadyStates.includes(p)));
    states.filter(s => !notReadyStates.includes(s)).forEach((s, i) => res[s] = [i, y]);
    actions.filter(a => !notReadyActions.includes(a)).forEach(([id], i) => res[id] = [i, y + 1]);
    if (notReadyStates.length)
      return idToPosition(notReadyActions, notReadyStates, res, y + 2);
    return res;
  }

  function setCallOnStateAndEdge(action, state, call, dict) {
    dict[state] = (dict[state] || '') + call;
    dict[action + ':' + state] = call;
  }

  function elementToCall(callSequence, actions) {
    const idToCall = {};
    for (let callId = 0; callId < callSequence.length; callId++) {
      const [actionId, status = 'i'] = callSequence[callId].split('_');
      const [id, params, fun, output, error] = actions[actionId];
      const call = `,${callId}_${status}`;
      idToCall[actionId] = (idToCall[actionId] || '') + call;
      if (status === 'i' || status === 'c')
        params.forEach(pState => setCallOnStateAndEdge(actionId, pState.replace('*', ''), call, idToCall));
      else if (status.indexOf('e') >= 0)
        setCallOnStateAndEdge(actionId, error, call, idToCall);
      else
        setCallOnStateAndEdge(actionId, output, call, idToCall);
    }
    return idToCall;
  }

  function makeEdgeObj([action, state, optional], idToPos, idToCall) {
    const [x, y] = idToPos[action];
    const [x2, y2] = idToPos[state];
    const call = idToCall[`${action}:${state}`];
    return {action, state, x, y, x2, y2, call, optional};
  }

  function computeOM(hash) {
    //converting the hash to obj
    let [actions, callSequence] = Array.from(JSON.parse(hash.replaceAll(/[*\w]+/g, s => `"${s}"`).replaceAll(/,,/g, s => ',null,')));
    //getting list of state names
    const states = actions.map(([ps, _, r, e]) => [...ps.map(p => p[0] === '*' ? p.substr(1) : p), r, e]).flat(1).filter((s, i, ar) => ar.indexOf(s) === i);                //filtering out the state names
    //getting list of edges
    const params = actions.map(([params], id) => params.map(p => [id, p.replace('*', ''), p[0] === '*'])).flat(1);  //array of all the params
    const results = actions.map(([ps, f, result], id) => [id, result]);
    const errors = actions.map(([ps, f, r, error], id) => [id, error]);

    //todo possible to skip..
    actions = actions.map((action, i) => [i, ...action]); //adding the id of the action at the beginning

    const idToPos = idToPosition(actions, states);
    const idToCall = elementToCall(callSequence, actions);

    const [maxX, maxY] = Object.values(idToPos).reduce(([max, may], [x, y]) => [Math.max(x, max), Math.max(y, may)], [0, 0]);

    return [
      states.map(s => ({id: s, x: idToPos[s][0], y: idToPos[s][1], call: idToCall[s]})),
      actions.map(([id, _, fun]) => ({id, fun, x: idToPos[id][0], y: idToPos[id][1], call: idToCall[id]})),
      params.map(p => makeEdgeObj(p, idToPos, idToCall)),
      results.map(r => makeEdgeObj(r, idToPos, idToCall)),
      errors.map(e => makeEdgeObj(e, idToPos, idToCall)),
      Math.max(maxX, maxY)
    ];
  }
</script>

<style id="dynamic"></style>

<style>
  #container {
    position: relative;
    width: min(100vw, 100vh);
    height: min(100vw, 100vh);
    font-size: 10px;
  }
  #container div {
    position: absolute;
    top: calc((var(--y) + 1) * var(--unit));
    left: calc((var(--x) + 1) * var(--unit));
  }
  .input, .output, .error {
    transform-origin: top left;
    transform: rotate(var(--angle, 0));
    width: calc(var(--diagonal) * var(--unit));
  }
  .state, .action {
    transform: translate(-50%, -50%);
    border: 2px solid black;
    width: calc(var(--unit) * .6);
    height: calc(var(--unit) * .4);
    background: white;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1;
  }

  .state { border-color: green; border-radius: 50%;}
  .action { border-color: blue;}
  .input { height: 2px; border-top: 2px solid darkgreen; }
  div.input[optional="true"] { border-top-style: dotted; }
  .output { height: 2px; border-top: 2px solid darkblue; }
  .error { height: 2px; border-top: 2px dotted orange; margin-left: 2px;}
</style>

<div id="container"></div>

<script src="https://unpkg.com/uhtml">/* global uhtml */</script>
<script>
  html = uhtml.html;
  render = uhtml.render;

  // import {render, html, svg} from 'https://unpkg.com/uhtml?module';
  function styleXY(x, y) {
    return `--x: ${x}; --y: ${y};`;
  }

  function styleXY2(y2, y, x2, x) {
    const a = Math.floor(Math.atan2(y2 - y, x2 - x) * 180 / Math.PI);
    const d = Math.sqrt(Math.pow(x2 - x, 2) + Math.pow(y2 - y, 2));
    return styleXY(x, y) + `--angle: ${a}deg; --diagonal: ${d};`
  }

  function updateView([states, actions, inputs, results, errors, displayUnit], step) {

    render(document.querySelector('style#dynamic'), html`${`
      div[call*=",${step}_"] { color: red; border-color: red; }
      :root{ --unit: ${Math.floor(100 / (displayUnit + 1))}%}
    `}`);


    render(document.querySelector('div'), html`
      ${inputs.map(({x, y, x2, y2, optional, call}) => html`
        <div class="input" style="${styleXY2(y2, y, x2, x)}" call="${call}" optional="${optional}">input</div>`)}
      ${results.map(({x, y, x2, y2, call}) => html`
        <div class="output" style="${styleXY2(y2, y, x2, x)}" call="${call}">result</div>`)}
      ${errors.map(({x, y, x2, y2, call}) => html`
        <div class="error" style="${styleXY2(y2, y, x2, x)}" call="${call}">error</div>`)}
      ${actions.map(({id, fun, x, y, call}) => html`
        <div class="action" id="${id}" style="${styleXY(x, y)}" call="${call}">${fun || `fun${id}`}</div>`)}
      ${states.map(({id, x, y, call}) => html`
        <div class="state" id="${id}" style="${styleXY(x, y)}" call="${call}">${id}</div>`)}
    `);
  }

  window.step = 7;
  window.model = computeOM(location.hash.substr(1));
  updateView(window.model, window.step);

  window.addEventListener('hashchange', e => {
    if (!location.hash) return;
    window.model = computeOM(location.hash.substr(1));
    updateView(window.model, window.step);
  });

  window.addEventListener('keydown', e => {
    e.key === 'ArrowRight' && ++window.step;
    e.key === 'ArrowLeft' && --window.step;
    updateView(window.model, window.step);
  });
</script>

<script>
  let test = `[[[[request],,a,a],[[request],,a,response],[[request],maybeError,hello,maybeError],[[maybeError],maybeErrorHandler,error,_error3],[[request],helloSunshine,response,_error4],[[error],errorToResult,response,response],[[response,*hello],log,_observer6,_error6]],[0,0_s,1_c,2,2_se,3,3_s,4,5,5_s,6,4_ba,6_sa]]`;
  location.hash = test;
</script>
1. Make main table.
A. List all state names and duplicate actions list.
B. Iterate the state names. Move all state names to next row in main table that is not an output state of any of the actions.
C. Iterate the actions duplicate. Move all actions to the next row in the main table that has no input that is listed in the states list.
Repeat B and C until empty state and duplicate actions lists.
D. Convert the main table into a map: state name/actionid =>[x, y].

3. Iterate actions list to make inputEdgeList.
A. For each input, make an entry with [actionid, state name, state koordinate, action koordinate].

5 and 7. Do the same as inputEdgeList, except for result and error.