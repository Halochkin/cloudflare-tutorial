<script>
  function idToPosition(actions, states, res = {}, y = 0) {
    //states which is an output in the actions
    const notReadyStates = states.filter(s => actions.find(([i, p, f, r, e]) => r === s || e === s));
    //actions which after ready states are removed, still lacks a required parameter
    const notReadyActions = actions.filter(([_, params]) => params.filter(p => p[0] !== '*').find(p => notReadyStates.includes(p)));
    states.filter(s => !notReadyStates.includes(s)).forEach((s, i) => res[s] = [i, y]);
    actions.filter(a => !notReadyActions.includes(a)).forEach(([id], i) => res[id] = [i, y + 1]);
    if (notReadyStates.length)
      return idToPosition(notReadyActions, notReadyStates, res, y + 2);
    return res;
  }

  function statusToProps(status, callId) {
    if (status === 'i') return {invoke: callId};
    if (status === 'c') return {resolve: callId, cancel: true};
    return {
      resolve: callId,
      async: status.indexOf('a') >= 0 || undefined,
      blocked: status.indexOf('b') >= 0 || undefined,
      isError: status.indexOf('e') >= 0 || undefined,
      isOutput: status.indexOf('o') >= 0 || undefined
    };
  }

  function computeOM(hash) {
    //converting the hash to obj
    let [actions, calls] = Array.from(JSON.parse(hash.replaceAll(/[*\w]+/g, s => `"${s}"`).replaceAll(/,,/g, s => ',null,')));
    //getting list of state names
    const states = actions.map(([ps, _, r, e]) => [...ps.map(p => p[0] === '*' ? p.substr(1) : p), r, e]).flat(1).filter((s, i, ar) => ar.indexOf(s) === i);                //filtering out the state names
    //getting list of edges
    actions = actions.map((action, i) => [i, ...action]); //adding the id of the action at the beginning

    const idToPos = idToPosition(actions, states);
    const [maxX, maxY] = Object.values(idToPos).reduce(([max, may], [x, y]) => [Math.max(x, max), Math.max(y, may)], [0, 0]);
    //actions to obj
    actions = actions.map(([id, inputs, fun, output, error]) => ({id, inputs, fun, output, error}));
    //adding call to actions
    const calls2 = [];
    for (let callId = 0; callId < calls.length; callId++) {
      const call = calls[callId];
      const [actionId, status] = call.split('_');
      const action = actions[actionId];
      calls2.push({id: callId, action: actionId, fun: action.fun, status});
      Object.assign(action, statusToProps(status, callId));
    }

    //actions {id, inputs, fun, output, error, invoke, resolve, cancel*, async*, isError*, isOutput*, blocked*}
    return [actions, states, idToPos, calls2, maxX, maxY];
  }
</script>

<style id="dynamic"></style>

<style>
  * {
    margin: 0; padding: 0; box-sizing: border-box;
  }
  #container {
    position: relative;
    margin: min(5vw, 5vh);
    width: min(90vw, 90vh);
    height: min(90vw, 90vh);
    font-size: 10px;
  }
  #container * {
    position: absolute;
  }
  #container ul {
    top: 0;
    right: 0;
  }
  #container ul li {
    position: relative;
  }
  #container ul li[current] {
    font-weight: bold;
  }
  flow-action, flow-state-placeholder {
    top: calc(var(--y) * var(--unit));
    left: calc(var(--x) * var(--unit));
    width: calc(var(--unit) * .5);
    height: calc(var(--unit) * .5);
  }
  flow-action {
    --state-color: lightgrey;
    --state-border: 0;
  }
  flow-action-placeholder, flow-state-placeholder {
    background: white;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  flow-action-placeholder {
    border: 2px solid blue;
    width: 90%;
    height: 90%;
  }
  flow-state-placeholder {
    border-radius: 50%;
    border: 2px solid lightgray;
  }
  flow-state-placeholder:first-of-type {
    border-color: green;
  }
  flow-state {
    width: 100%;
    height: 100%;
    border-radius: 0 50% 50% 50%;
    border: var(--state-border) solid var(--state-color);
    transform-origin: center;
    transform: rotate(calc(var(--angle) - 45deg));
    top: calc(var(--y) * 200%);
    left: calc(var(--x) * 200%);
    background: radial-gradient(circle at 100% 100%, transparent 85%, var(--state-color));
  }

  flow-edge {
    border-top: 2px solid var(--state-color);
    width: calc(var(--diagonal) * 200% - 76%);
    transform-origin: top left;
    transform: rotate(var(--angle));
    top: 50%;
    left: 50%;
  }
  flow-action[resolve][blocked] > [type="output"] {--state-color: red;}
  flow-action[resolved][blocked] > flow-state[type="output"] {--state-color: red;}
  flow-action[resolved][cancelled] > [type="output"] {--state-color: black;}


  flow-action[resolve][error]:not([blocked]) > [type="error"] {--state-color: orange; --state-border: 2px; background-color: rgba(255, 0, 0, 0.3);}
  flow-action[resolved][error]:not([blocked]) > flow-state[type="error"] {--state-color: orange; --state-border: 2px;}

  flow-action[resolve][output]:not([blocked]) > [type="output"] { --state-color: green; background-color: rgba(0, 255, 0, 0.3);}
  flow-action[resolved][output]:not([blocked]) > flow-state[type="output"] {--state-color: green; --state-border: 2px;}
  flow-action[invoke] > [type="input"] {--state-color: green; --state-border: 2px; background-color: rgba(0, 255, 0, 0.3);}

  flow-action[resolved]:not([resolve]) > flow-action-placeholder { border-color: lightgrey; }
  flow-action[invoked]:not([invoke]) > flow-action-placeholder { border-color: lightgrey; }
  flow-action[invoked]:not([resolved]) > flow-action-placeholder,
  flow-action[resolve] > flow-action-placeholder { background: lightblue; }

  flow-edge[optional] {border-top-style: dotted}
</style>

<div id="container"></div>

<script src="https://unpkg.com/uhtml">/* global uhtml */</script>
<script>
  html = uhtml.html;
  render = uhtml.render;

  function styleXY(x, y) {
    return `--x: ${x}; --y: ${y};`;
  }

  function styleXY2(x, y) {
    const a = Math.atan2(y, x) * 180 / Math.PI;
    const d = Math.sqrt(x * x + y * y);
    return `--x: ${x}; --y: ${y}; --angle: ${a}deg; --diagonal: ${d};`
  }

  //actions {id, inputs, fun, output, error, invoke, resolve}
  function updateView([actions, states, idToPos, calls, maxX, maxY], step) {
    render(document.querySelector('style#dynamic'), html`${`
      :root{ --unit: ${Math.floor(100 / (Math.max(maxY, maxX) + 1))}%}
    `}`);


    render(document.querySelector('#container'), html`
      <ul>
        ${calls.map(({id, action, fun, status}, i) => html`
          <li id=${"call" + id} action=${action} status=${status} current=${i === step || undefined}>
            ${fun || 'fun' + action}>${status}
          </li>`)}
      </ul>

      ${states.map(state => html`
        <flow-state-placeholder class="action" style=${styleXY(...idToPos[state])}>${state}</flow-state-placeholder>`)}

      ${actions.map(action => {
      let {id, inputs, fun, output, error, invoke, resolve, cancel, async, isError, isOutput, blocked} = action;

      const [x, y] = idToPos[id];
      const [xO, yO] = idToPos[output];
      const [xE, yE] = idToPos[error];

      const isInvoking = invoke === step || undefined;
      const isResolving = resolve === step || undefined;
      const resolved = resolve <= step || undefined;
      const invoked = resolved || invoke <= step || undefined;
      const pending = step > invoke && step < resolve || undefined;

      return html`
          <flow-action style=${styleXY(x, y)}
                       invoked=${invoked} invoke=${isInvoking} pending=${pending} resolve=${isResolving}
                       resolved=${resolved}
                       async=${async} blocked=${blocked} cancelled=${cancel} error=${isError} output=${isOutput}>

            <flow-edge type=error style=${styleXY2(xE - x, yE - y)}></flow-edge>
            <flow-state type=error style=${styleXY2(xE - x, yE - y)} resolve=${resolve} step=${step}></flow-state>

            <flow-edge type=output style=${styleXY2(xO - x, yO - y)}></flow-edge>
            <flow-state type=output style=${styleXY2(xO - x, yO - y)} resolve=${resolve} step=${step}></flow-state>

            ${inputs.map(input => {
        const optional = input[0] === '*' || undefined;
        input = optional ? input.substr(1) : input;
        const [xI, yI] = idToPos[input];
        return html`
                <flow-edge type=input style=${styleXY2(xI - x, yI - y)} optional=${optional}></flow-edge>
                <flow-state type=input style=${styleXY2(xI - x, yI - y)} invoke=${invoke} step=${step}
                            optional=${optional}></flow-state>
              `;
      })}
            <flow-action-placeholder>${fun || 'fun' + id}</flow-action-placeholder>
          </flow-action>
        `;
    })}
    `);
  }

  function init() {
    if (!location.hash) return;
    model = computeOM(location.hash.substr(1));
    step = maxSteps = model[3].length - 1;
    updateView(model, step);
  }

  function clamp(min, nextStep, max) {
    return nextStep > max ? min : nextStep < min ? max : nextStep;
  }

  init();

  window.addEventListener('hashchange', init);

  window.addEventListener('keydown', e => {
    e.key === 'ArrowRight' && (step = clamp(0, ++step, maxSteps));
    e.key === 'ArrowLeft' && (step = clamp(0, --step, maxSteps));
    updateView(model, step);
  });
</script>

<script>
  let test = `[[[[request],,a,a],[[request],,a,response],[[request],maybeError,hello,maybeError],[[maybeError],maybeErrorHandler,error,_error3],[[request],helloSunshine,response,_error4],[[error],errorToResult,response,response],[[response,*hello],log,_observer6,_error6]],[0_i,0_o,1_c,2_i,2_e,3_i,3_o,4_i,5_i,5_o,6_i,4_aob,6_ao]]`;
  location.hash = test;
</script>


1. Make main table.
A. List all state names and duplicate actions list.
B. Iterate the state names. Move all state names to next row in main table that is not an output state of any of the actions.
C. Iterate the actions duplicate. Move all actions to the next row in the main table that has no input that is listed in the states list.
Repeat B and C until empty state and duplicate actions lists.
D. Convert the main table into a map: state name/actionid =>[x, y].

3. Iterate actions list to make inputEdgeList.
A. For each input, make an entry with [actionid, state name, state koordinate, action koordinate].

5 and 7. Do the same as inputEdgeList, except for result and error.