<style id="dynamic"></style>

<style>
  #container {
    position: relative;
    width: min(100vw, 100vh);
    height: min(100vw, 100vh);
    font-size: 10px;
  }
  #container div {
    position: absolute;
    top: calc((var(--y) + 1) * var(--unit));
    left: calc((var(--x) + 1) * var(--unit));
  }
  .input, .output, .error {
    transform-origin: top left;
    transform: rotate(var(--angle, 0));
    width: calc(var(--diagonal) * var(--unit));
  }
  .state, .action {
    transform: translate(-50%, -50%);
    border: 2px solid black;
    width: calc(var(--unit) * .6);
    height: calc(var(--unit) * .4);
    background: white;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1;
  }

  .state { border-color: green; border-radius: 50%;}
  .action { border-color: blue;}
  .input { height: 2px; border-top: 2px solid darkgreen; }
  .output { height: 2px; border-top: 2px solid darkblue; }
  .error { height: 2px; border-top: 2px dotted orange; margin-left: 2px;}
</style>

<div id="container"></div>

<script src="https://unpkg.com/uhtml">/* global uhtml */</script>

<script>
  html = uhtml.html;
  render = uhtml.render;
  // import {render, html, svg} from 'https://unpkg.com/uhtml?module';

  //todo reducer
  //todo reducer
  //todo reducer
  function hashToObj(raw) {
    return JSON.parse(raw
      .replaceAll(/[*\w]+/g, s => `"${s}"`)
      .replaceAll(/,,/g, s => ',null,'));
  }

  function stateNames(actions) {
    return actions
      .map(([ps, _, r, e]) => [...ps, r, e])
      .flat(1)
      .map(s => s[0] === '*' ? s.substr(1) : s)
      .filter((s, i, ar) => ar.indexOf(s) === i);
  }

  function splitInTwo(array, isValid) {
    return array.reduce(([pass, fail], el) => isValid(el) ? [[...pass, el], fail] : [pass, [...fail, el]], [[], []]);
  }

  function stateActionSequence(actions, states) {
    if (states.length === 0)
      return [];
    const [readyS, restS] = splitInTwo(states, id => !actions.find(({result, error}) => result === id || error === id));
    const [readyA, restA] = splitInTwo(actions, ({params}) => params.every(p => !restS.includes(p[0] === '*' ? p.substr(1) : p)));
    const result = stateActionSequence(restA, restS);
    readyA.length && result.unshift(readyA);
    result.unshift(readyS.map(state => ({id: state, type: 'state'})));
    return result;
  }

  function addCoordinatesIdKeyAndCalcUnit(table) {
    const res = {};
    let x = table.length;
    for (let y = 0; y < table.length; y++) {
      table[y].length > x && (x = table[y].length);
      for (let x = 0; x < table[y].length; x++) {
        table[y][x].pos = [x, y];
        table[y][x].x = x;
        table[y][x].y = y;
        res[table[y][x].id] = table[y][x];
      }
    }
    return [res, x];
  }

  function actionToCallSequence(idToPos, callSequence) {
    for (let i = 0; i < callSequence.length; i++) {
      let call = callSequence[i];
      const [actionId, type] = call.split('_');
      const action = idToPos[actionId];
      type === undefined ? action.invoke = i : (action.resolve = i, action.status = type);
    }
  }

  function convertEdges(idToPos) {
    for (let i = 0, action; action = idToPos[i]; i++) {
      let {params, fun, result, error, id, invoke, resolve, status, x, y} = action;
      action.params = params.map(p => {
        const optional = p[0] === '*';
        const state = optional ? p.substr(1) : p;
        const st = idToPos[state];
        return {state, x: st.x, y: st.y, x2: x, y2: y, action: id, optional, invoke, type: 'input'};
      });
      action.result = {state: result, x, y, x2: idToPos[result].x, y2: idToPos[result].y, action: id, type: 'output'};
      action.error = {state: error, x, y, x2: idToPos[error].x, y2: idToPos[error].y, action: id, type: 'error'};
      if (status.indexOf('e') >= 0) {
        action.error.resolve = resolve;
        action.error.status = status;
      } else {
        action.result.resolve = resolve;
        action.result.status = status;
      }
    }
  }

  function computeOM(hash) {
    let [actions, callSequence] = Array.from(hashToObj(hash));
    const mainTable = stateActionSequence(
      actions.map(([params, fun, result, error], id) => ({params, fun, result, error, id, type: 'action'})),
      stateNames(actions)
    );

    const [idToPos, unit] = addCoordinatesIdKeyAndCalcUnit(mainTable);
    actionToCallSequence(idToPos, callSequence);
    convertEdges(idToPos);
    const units = Object.values(idToPos);
    actions = units.filter(({type}) => type === 'action');
    const states = units.filter(({type}) => type === 'state');
    const edges = [
      ...actions.map(({params}) => params).flat(1),
      ...actions.map(({result}) => result),
      ...actions.map(({error}) => error)
    ];
    return [actions, states, edges, unit];
  }


  function updateView([actions, states, edges, displayUnit], step) {

    render(document.querySelector('style#dynamic'), html`${`
      div[invoke="${step}"], div[resolve="${step}"] { color: red; }
      :root{ --unit: ${Math.floor(100 / (displayUnit + 1))}%}
    `}`);

    //make the angles and lines
    edges.forEach(e => {
      e.angle = Math.floor(Math.atan2(e.y2 - e.y, e.x2 - e.x) * 180 / Math.PI);
      e.diagonal = Math.sqrt(Math.pow((e.x2 - e.x), 2) + Math.pow((e.y2 - e.y), 2));
      e.style = ` --angle: ${(e.angle)}deg; --diagonal: ${(e.diagonal)};`
    });
    //add the positions
    states.forEach(s => s.style = `--x: ${s.x}; --y: ${s.y};`);
    actions.forEach(a => a.style = `--x: ${a.x}; --y: ${a.y};`);
    edges.forEach(e => e.style += `--x: ${e.x}; --y: ${e.y};`);

    render(document.querySelector('div'), html`
      ${edges.map(e => html`
        <div style="${(e.style)}" class="${(e.type)}">${e.optional ? '*' : ''}</div>`)}
      ${actions.map(a => html`
        <div id="${(a.id)}" class="action" style="${(a.style)}" invoke="${a.invoke}" resolve="${a.resolve}"
             status="${a.status}">${a.fun || 'fun' + a.id}
        </div>`)}
      ${states.map(s => html`
        <div style="${s.style}" class="${(s.type)}" id="${(s.id)}">${(s.id)}</div>`)}
    `);
  }

  window.step = 7;
  updateView(computeOM(location.hash.substr(1)), window.step);
  window.addEventListener('hashchange', e => location.hash && updateView(computeOM(location.hash.substr(1))));

  window.addEventListener('keydown', e => {
    e.key === 'ArrowRight' && updateView(computeOM(location.hash.substr(1)), ++window.step);
    e.key === 'ArrowLeft' && updateView(computeOM(location.hash.substr(1)), --window.step);
  });
</script>

<script>
  let test = `[[[[request],,a,a],[[request],,a,response],[[request],maybeError,hello,maybeError],[[maybeError],maybeErrorHandler,error,_error3],[[request],helloSunshine,response,_error4],[[error],errorToResult,response,response],[[response,*hello],log,_observer6,_error6]],[0,0_s,1_c,2,2_se,3,3_s,4,5,5_s,6,4_ba,6_sa]]`;
  location.hash = test;
</script>
1. Make main table.
A. List all state names and duplicate actions list.
B. Iterate the state names. Move all state names to next row in main table that is not an output state of any of the actions.
C. Iterate the actions duplicate. Move all actions to the next row in the main table that has no input that is listed in the states list.
Repeat B and C until empty state and duplicate actions lists.
D. Convert the main table into a map: state name/actionid =>[x, y].

3. Iterate actions list to make inputEdgeList.
A. For each input, make an entry with [actionid, state name, state koordinate, action koordinate].

5 and 7. Do the same as inputEdgeList, except for result and error.