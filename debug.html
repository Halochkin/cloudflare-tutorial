<script>
  function idToPosition(actions, states, res = {}, y = 0) {
    //states which is an output in the actions
    const notReadyStates = states.filter(s => actions.find(([i, p, f, r, e]) => r === s || e === s));
    //actions which after ready states are removed, still lacks a required parameter
    const notReadyActions = actions.filter(([_, params]) => params.filter(p => p[0] !== '*').find(p => notReadyStates.includes(p)));
    states.filter(s => !notReadyStates.includes(s)).forEach((s, i) => res[s] = [i, y]);
    actions.filter(a => !notReadyActions.includes(a)).forEach(([id], i) => res[id] = [i, y + 1]);
    if (notReadyStates.length)
      return idToPosition(notReadyActions, notReadyStates, res, y + 2);
    return res;
  }

  function statusToProps(status, callId) {
    if (status === 'i') return {invoke: callId};
    if (status === 'c') return {resolve: callId, cancel: true};
    return {
      resolve: callId,
      async: status.indexOf('a') >= 0 || undefined,
      blocked: status.indexOf('b') >= 0 || undefined,
      isError: status.indexOf('e') >= 0 || undefined,
      isOutput: status.indexOf('o') >= 0 || undefined
    };
  }

  function computeOM(actions, calls) {
    //converting the hash to obj
    // let [actions, calls] = Array.from(JSON.parse(actionsCalls.replaceAll(/[*\w]+/g, s => `"${s}"`).replaceAll(/,,/g, s => ',null,')));
    //getting list of state names
    const states = actions.map(([ps, _, r, e]) => [...ps.map(p => p[0] === '*' ? p.substr(1) : p), r, e]).flat(1).filter((s, i, ar) => ar.indexOf(s) === i);                //filtering out the state names
    //getting list of edges
    actions = actions.map((action, i) => [i, ...action]); //adding the id of the action at the beginning

    const idToPos = idToPosition(actions, states);
    const [maxX, maxY] = Object.values(idToPos).reduce(([max, may], [x, y]) => [Math.max(x, max), Math.max(y, may)], [0, 0]);
    //actions to obj
    actions = actions.map(([id, inputs, fun, output, error]) => ({id, inputs, fun, output, error}));
    //adding call to actions
    const calls2 = [];
    for (let callId = 0; callId < calls.length; callId++) {
      const call = calls[callId];
      const [actionId, status] = call.split('_');
      const action = actions[actionId];
      calls2.push({id: callId, action: actionId, fun: action.fun, status});
      Object.assign(action, statusToProps(status, callId));
    }

    //actions {id, inputs, fun, output, error, invoke, resolve, cancel*, async*, isError*, isOutput*, blocked*}
    return [actions, states, idToPos, calls2, maxX, maxY];
  }
</script>

<style id="dynamic"></style>

<style>
  * {
    margin: 0; padding: 0; box-sizing: border-box;
  }

  #calls {
    position: absolute;
    top: min(10vw, 10vh);
    right: min(10vw, 10vh);
    height: min(20vw, 20vh);
    overflow: scroll;
  }
  #calls li {
    position: relative;
  }
  #calls li[current] {
    font-weight: bold;
  }

  #state summary {
    color: lightgray;
  }
  #state summary[active] {
    color: green;
  }

  #state {
    position: absolute;
    top: min(30vw, 30vh);
    right: min(10vw, 10vh);
  }

  #container {
    position: relative;
    margin: min(5vw, 5vh);
    width: min(90vw, 90vh);
    height: min(90vw, 90vh);
    font-size: 10px;
  }
  #container * {
    position: absolute;
  }
  flow-action, flow-state-placeholder {
    top: calc(var(--y) * var(--unit));
    left: calc(var(--x) * var(--unit));
    width: calc(var(--unit) * .5);
    height: calc(var(--unit) * .5);
  }
  flow-action {
    --state-color: lightgrey;
    --state-border: 0;
  }
  flow-action-placeholder, flow-state-placeholder {
    background: white;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  flow-action-placeholder {
    border: 2px solid blue;
    width: 90%;
    height: 90%;
  }
  flow-state-placeholder {
    border-radius: 50%;
    border: 2px solid lightgray;
  }
  flow-state-placeholder:first-of-type {
    border-color: green;
  }
  flow-state {
    width: 100%;
    height: 100%;
    border-radius: 2% 50% 50% 50%;
    border: var(--state-border) solid var(--state-color);
    transform-origin: center;
    transform: rotate(calc(var(--angle) - 45deg));
    top: calc(var(--y) * 200%);
    left: calc(var(--x) * 200%);
    background: radial-gradient(circle at 100% 100%, transparent 85%, var(--state-color));
  }

  flow-edge {
    border-top: 2px solid var(--state-color);
    width: calc(var(--diagonal) * 200% - 76%);
    transform-origin: top left;
    transform: rotate(var(--angle));
    top: 50%;
    left: 50%;
  }
  flow-action[resolve][blocked] > [type="output"] {--state-color: red;}
  flow-action[resolved][blocked] > flow-state[type="output"] {--state-color: red;}
  flow-action[resolve][cancelled] > [type="output"] {--state-color: black;}
  flow-action[resolved][cancelled] > flow-state[type="output"] {--state-color: black;}


  flow-action[resolve][error]:not([blocked]) > [type="error"] {--state-color: orange; --state-border: 2px; background-color: rgba(255, 0, 0, 0.3);}
  flow-action[resolved][error]:not([blocked]) > flow-state[type="error"] {--state-color: orange; --state-border: 2px;}

  flow-action[resolve][output]:not([blocked]) > [type="output"] { --state-color: green; background-color: rgba(0, 255, 0, 0.3);}
  flow-action[resolved][output]:not([blocked]) > flow-state[type="output"] {--state-color: green; --state-border: 2px;}
  flow-action[invoke] > [type="input"] {--state-color: green; --state-border: 2px; background-color: rgba(0, 255, 0, 0.3);}

  flow-action[resolved]:not([resolve]) > flow-action-placeholder { border-color: lightgrey; }
  flow-action[invoked]:not([invoke]) > flow-action-placeholder { border-color: lightgrey; }
  flow-action[invoked]:not([resolved]) > flow-action-placeholder,
  flow-action[resolve] > flow-action-placeholder { background: lightblue; }

  flow-edge[optional] {border-top-style: dotted}
</style>

<div id="container"></div>
<ul id="calls"></ul>
<div id="state"></div>

<script src="https://unpkg.com/uhtml">/* global uhtml */</script>
<script>
  html = uhtml.html;
  render = uhtml.render;

  function styleXY(x, y) {
    return `--x: ${x}; --y: ${y};`;
  }

  function styleXY2(x, y) {
    const a = Math.atan2(y, x) * 180 / Math.PI;
    const d = Math.sqrt(x * x + y * y);
    return `--x: ${x}; --y: ${y}; --angle: ${a}deg; --diagonal: ${d};`
  }

  function printAction(action, idToPos, step) {
    let {id, inputs, fun, output, error, invoke, resolve, cancel, async, isError, isOutput, blocked} = action;

    const [x, y] = idToPos[id];
    const [xO, yO] = idToPos[output];
    const [xE, yE] = idToPos[error];

    const isInvoking = invoke === step || undefined;
    const isResolving = resolve === step || undefined;
    const resolved = resolve <= step || undefined;
    const invoked = resolved || invoke <= step || undefined;
    const pending = step > invoke && step < resolve || undefined;

    return html`
      <flow-action style=${styleXY(x, y)}
                   invoked=${invoked} invoke=${isInvoking} pending=${pending} resolve=${isResolving}
                   resolved=${resolved}
                   async=${async} blocked=${blocked} cancelled=${cancel} error=${isError} output=${isOutput}>

        <flow-edge type=error style=${styleXY2(xE - x, yE - y)}></flow-edge>
        <flow-state type=error style=${styleXY2(xE - x, yE - y)} resolve=${resolve} step=${step}></flow-state>

        <flow-edge type=output style=${styleXY2(xO - x, yO - y)}></flow-edge>
        <flow-state type=output style=${styleXY2(xO - x, yO - y)} resolve=${resolve} step=${step}></flow-state>

        ${inputs.map(input => {
          const optional = input[0] === '*' || undefined;
          input = optional ? input.substr(1) : input;
          const [xI, yI] = idToPos[input];
          return html`
            <flow-edge type=input style=${styleXY2(xI - x, yI - y)} optional=${optional}></flow-edge>
            <flow-state type=input style=${styleXY2(xI - x, yI - y)} invoke=${invoke} step=${step}
                        optional=${optional}></flow-state>
          `;
        })}
        <flow-action-placeholder>${fun || 'fun' + id}</flow-action-placeholder>
      </flow-action>
    `;
  }

  function renderCall(id, action, status, i, step, fun) {
    return html`
      <li id=${"call" + id} action=${action} status=${status} current=${i === step || undefined}>
        ${fun || 'fun' + action}>${status}
      </li>`;
  }

  function renderStatePlaceHolder(idToPos, state) {
    return html`
      <flow-state-placeholder class="action" style=${styleXY(...idToPos[state])}>${state}</flow-state-placeholder>`;
  }

  function renderStateDetails(prop, value, active) {
    return html`
      <details>
        <summary active=${active}>${prop}</summary>
        <pre>${JSON.stringify(value, null, 2)}</pre>
      </details>`;
  }

  //actions {id, inputs, fun, output, error, invoke, resolve}
  function updateView([actions, states, idToPos, calls, maxX, maxY], variables, step) {
    render(document.querySelector('style#dynamic'), html`${`
      :root{ --unit: ${Math.floor(100 / (Math.max(maxY, maxX) + 1))}%}
    `}`);

    render(document.querySelector('#calls'), html`
      ${calls.map(({id, action, fun, status}, i) => renderCall(id, action, status, i, step, fun))}
    `);

    render(document.querySelector('#container'), html`
      ${states.map(state => renderStatePlaceHolder(idToPos, state))}
      ${actions.map(action => printAction(action, idToPos, step))}
    `);

    render(document.querySelector('#state'), html`
      ${Object.entries(variables).map(([prop, value]) => {
        const relevantCalls = calls.slice(0, step + 1);
        const active = relevantCalls.find(call => (actions[call.action].inputs.find(input => input === prop)) || (call.status.indexOf('o') >= 0 && actions[call.action].output === prop) || (call.status.indexOf('e') >= 0 && actions[call.action].error === prop))
        return renderStateDetails(prop, value, active)
      })}`);
  }

  function init() {
    if (!location.hash) return;
    const {actions, sequence,variables} = JSON.parse(atob(location.hash.substr(1)));
    window.variables = variables;
    model = computeOM(actions, sequence);
    step = 0;
    maxSteps = model[3].length - 1;
    updateView(model, variables, step);
  }

  function clamp(min, nextStep, max) {
    return nextStep > max ? min : nextStep < min ? max : nextStep;
  }

  init();

  window.addEventListener('hashchange', init);

  window.addEventListener('keydown', e => {
    e.key === 'ArrowRight' && (step = clamp(0, ++step, maxSteps));
    e.key === 'ArrowLeft' && (step = clamp(0, --step, maxSteps));
    updateView(model, variables, step);
  });
</script>

<script>
  let test = `eyJhY3Rpb25zIjpbW1sicmVxdWVzdCJdLCIiLCJhIiwiYSJdLFtbInJlcXVlc3QiXSwiIiwiYSIsInJlc3BvbnNlIl0sW1sicmVxdWVzdCJdLCJtYXliZUVycm9yIiwiaGVsbG8iLCJtYXliZUVycm9yIl0sW1sibWF5YmVFcnJvciJdLCJtYXliZUVycm9ySGFuZGxlciIsImVycm9yIiwiX2Vycm9yMyJdLFtbInJlcXVlc3QiXSwiaGVsbG9TdW5zaGluZSIsInJlc3BvbnNlIiwiX2Vycm9yNCJdLFtbImVycm9yIl0sImVycm9yVG9SZXN1bHQiLCJyZXNwb25zZSIsInJlc3BvbnNlIl0sW1sicmVzcG9uc2UiLCIqaGVsbG8iXSwibG9nIiwiX29ic2VydmVyNiIsIl9lcnJvcjYiXV0sInNlcXVlbmNlIjpbIjBfaSIsIjBfbyIsIjFfYyIsIjJfaSIsIjJfZSIsIjNfaSIsIjNfbyIsIjRfaSIsIjVfaSIsIjVfbyIsIjZfaSIsIjRfYW9iIiwiNl9hbyJdLCJ2YXJpYWJsZXMiOnsicmVxdWVzdCI6eyJ1cmwiOiJodHRwczovL3ZnLm5vL2Vycm9yIn0sImEiOiIxIiwibWF5YmVFcnJvciI6e30sImVycm9yIjp7InN0YXR1cyI6NDAzfSwicmVzcG9uc2UiOnt9LCJfb2JzZXJ2ZXI2IjpudWxsfX0=`;
  location.hash = test;
</script>

Todo:
1. add state data when you press on it.
2. add function code when you press on action.
3. make the animation nicer.
4. make a bar in the animation list under setting of response, and make a special arrow in the map light up when the response is set.
5. make a visualisation of waitUntil and respondWith and notWaitedFor.
6. if there are other states used, but not given in, then mark those as syntax errors.
7. states such as `a` should be marked as `not observeds`.
8. etc.