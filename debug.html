<style>
  #container {
    position: relative;
    width: min(100vw, 100vh);
    height: min(100vw, 100vh);
    font-size: 10px;
  }
  #container div {
    position: absolute;
    top: calc((var(--y) + 1) * var(--unit));
    left: calc((var(--x) + 1) * var(--unit));
  }
  .input, .output, .error {
    transform-origin: top left;
    transform: rotate(var(--angle, 0));
    width: calc(var(--diagonal) * var(--unit));
  }
  .state, .action {
    transform: translate(-50%, -50%);
    border: 2px solid black;
    width: calc(var(--unit) * .6);
    height: calc(var(--unit) * .4);
    background: white;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .state { border-color: green; border-radius: 50%;}
  .action { border-color: blue;}
  .input { height: 2px; border-top: 2px solid darkgreen; }
  .output { height: 2px; border-top: 2px solid darkblue; }
  .error { height: 2px; border-top: 2px dotted orange; margin-left: 2px;}
</style>

<div id="container"></div>

<script>

  function hashToObj(raw) {
    return JSON.parse(raw
      .replaceAll(/[*_a-zA-Z][\w\d]*/g, s => `"${s}"`)
      .replaceAll(/,,/g, s => ',null,'));
  }

  function stateNames(actions) {
    const stateNames = new Set();
    for (let [args, fun, prop, propError] of actions) {
      args.forEach(param => stateNames.add(param[0] === '*' ? param.substr(1) : param));
      stateNames.add(prop);
      stateNames.add(propError);
    }
    return Array.from(stateNames);
  }

  function splitInTwo(array, isValid) {
    return array.reduce(([pass, fail], el) => isValid(el) ? [[...pass, el], fail] : [pass, [...fail, el]], [[], []]);
  }

  function stateActionSequence(actions, states) {
    if (states.length === 0 && actions.length === 0)
      return [];
    const [readyS, restS] = splitInTwo(states, name => !actions.find(action => action[2] === name || action[3] === name));
    const [readyA, restA] = splitInTwo(actions, ([params]) => params.every(p => !restS.includes(p[0] === '*' ? p.substr(1) : p)));
    const result = stateActionSequence(restA, restS);
    readyA.length && result.unshift(readyA);
    result.unshift(readyS);
    return result;
  }

  function toCoordinates(mainTable) {
    const map = new Map();
    for (let y = 0; y < mainTable.length; y++) {
      let rowEntries = mainTable[y];
      for (let x = 0; x < rowEntries.length; x++)
        map.set(rowEntries[x], [x, y]);
    }
    return map;
  }

  function makeVector(one, two, mainMap, number, optional) {
    return {coordinate: [mainMap.get(two), mainMap.get(one)], number, optional};
  }

  function inputEdges(actions, mainMap) {
    return actions.map(action => action[0].map(param => makeVector(action, param[0] === '*' ? param.substr(1) : param, mainMap, undefined, param[0] === '*')));
  }

  function outputEdges(actions, mainMap) {
    return actions.map(action => makeVector(action[2], action, mainMap, action[6] === 'success' ? action[5] : undefined));
  }

  function errorEdges(actions, mainMap) {
    return actions.map(action => makeVector(action[3], action, mainMap, action[6] === 'error' ? action[5] : undefined));
  }

  function getUnit(mainTable) {
    const X = mainTable.reduce((prevMaxLength, currentRow) => Math.max(prevMaxLength, currentRow.length), 0);
    return Math.floor(100 / (Math.max(mainTable.length, X) + 1));
  }

  function printCoordinate([x, y], xy2) {
    let pos = `--x: ${x}; --y: ${y};`;
    if (!xy2)
      return pos;
    let [x2, y2] = xy2;
    const angle = Math.floor(Math.atan2(y2 - y, x2 - x) * 180 / Math.PI);
    const diagonal = Math.sqrt(Math.pow((x2 - x), 2) + Math.pow((y2 - y), 2));
    return pos + ` --angle: ${angle}deg; --diagonal: ${diagonal};`;
  }

  function makeElement(unit, pos) {
    const isState = !(pos[1] % 2);
    const div = document.createElement('div');
    div.innerText = isState ? unit : unit[1] || 'function';
    div.style.cssText = printCoordinate(pos);
    div.classList.add(isState ? 'state' : 'action');
    return div;
  }

  function makeElementEdge(type, {coordinate, number, optional}) {
    const div = document.createElement('div');
    number !== undefined && (div.innerText = number);
    optional && (div.innerText += '*');
    div.style.cssText = printCoordinate(...coordinate);
    div.classList.add(type);
    return div;
  }

  function render() {
    if (!location.hash)
      return;
    const actions = Array.from(hashToObj(location.hash.substr(1)));
    const states = stateNames(actions);
    const mainTable = stateActionSequence(actions, states);

    document.styleSheets[0].insertRule(`:root{ --unit: ${getUnit(mainTable)}%}`)

    const mainMap = toCoordinates(mainTable);
    const params = inputEdges(actions, mainMap);
    const output = outputEdges(actions, mainMap);
    const errors = errorEdges(actions, mainMap);
    const html = []
      .concat(output.map(edge => makeElementEdge('output', edge)))
      .concat(errors.map(edge => makeElementEdge('error', edge)))
      .concat(params.flat(Infinity).map(edge => makeElementEdge('input', edge)))
    .concat(Array.from(mainMap.entries()).map(([unit, pos]) => makeElement(unit, pos)))
    ;
    const mainDiv = document.querySelector('div');
    html.forEach(el => mainDiv.append(el));
  }

  render();
  window.addEventListener('hashchange', render);
</script>

<script>
  let test = `
  [[[request],,a,a,0,1,success,set],[[request],,a,response,2,3,prelaunch,blocked],[[request],maybeError,hello,maybeError,4,5,error,set],[[maybeError],maybeErrorHandler,error,_error3,6,7,success,set],[[request],helloSunshine,response,_error4,8,12,async_success,blocked],[[error],errorToResult,response,response,9,10,success,set],[[response,*hello],log,_observer6,_error6,11,13,async_success,set]]
  `;
  location.hash = test.trim();
</script>
1. Make main table.
A. List all state names and duplicate actions list.
B. Iterate the state names. Move all state names to next row in main table that is not an output state of any of the actions.
C. Iterate the actions duplicate. Move all actions to the next row in the main table that has no input that is listed in the states list.
Repeat B and C until empty state and duplicate actions lists.
D. Konvert the main table into a map: state name/actionid =>[x, y].

3. Iterate actions list to make inputEdgeList.
A. For each input, make an entry with [actionid, state name, state koordinate, action koordinate].

5 and 7. Do the same as inputEdgeList, except for result and error.

