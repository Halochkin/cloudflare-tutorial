<style>
  #container {
    position: relative;
    width: min(100vw, 100vh);
    height: min(100vw, 100vh);
    font-size: 10px;
  }
  #container div {
    position: absolute;
    top: calc((var(--y) + 1) * var(--unit));
    left: calc((var(--x) + 1) * var(--unit));
  }
  .input, .output, .error {
    transform-origin: top left;
    transform: rotate(var(--angle, 0));
    width: calc(var(--diagonal) * var(--unit));
  }
  .state, .action {
    transform: translate(-50%, -50%);
    border: 2px solid black;
    width: calc(var(--unit) * .6);
    height: calc(var(--unit) * .4);
    background: white;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1;
  }

  .state { border-color: green; border-radius: 50%;}
  .action { border-color: blue;}
  .input { height: 2px; border-top: 2px solid darkgreen; }
  .output { height: 2px; border-top: 2px solid darkblue; }
  .error { height: 2px; border-top: 2px dotted orange; margin-left: 2px;}
</style>

<div id="container"></div>

<script>

  //todo reducer
  //todo reducer
  //todo reducer
  function hashToObj(raw) {
    return JSON.parse(raw
      .replaceAll(/[*\w]+/g, s => `"${s}"`)
      .replaceAll(/,,/g, s => ',null,'));
  }

  function stateNames(actions) {
    return actions
      .map(([ps, _, r, e]) => [...ps, r, e])
      .flat(1)
      .map(s => s[0] === '*' ? s.substr(1) : s)
      .filter((s, i, ar) => ar.indexOf(s) === i);
  }

  function splitInTwo(array, isValid) {
    return array.reduce(([pass, fail], el) => isValid(el) ? [[...pass, el], fail] : [pass, [...fail, el]], [[], []]);
  }

  function stateActionSequence(actions, states) {
    if (states.length === 0)
      return [];
    const [readyS, restS] = splitInTwo(states, id => !actions.find(({result, error}) => result === id || error === id));
    const [readyA, restA] = splitInTwo(actions, ({params}) => params.every(p => !restS.includes(p[0] === '*' ? p.substr(1) : p)));
    const result = stateActionSequence(restA, restS);
    readyA.length && result.unshift(readyA);
    result.unshift(readyS.map(state => ({id: state})));
    return result;
  }

  function addCoordinatesIdKeyAndCalcUnit(table) {
    const res = {};
    let x = table.length;
    for (let y = 0; y < table.length; y++) {
      table[y].length > x && (x = table[y].length);
      for (let x = 0; x < table[y].length; x++) {
        table[y][x].pos = [x, y];
        res[table[y][x].id] = table[y][x];
      }
    }
    return [res, x];
  }

  function actionToCallSequence(idToPos, callSequence) {
    for (let i = 0; i < callSequence.length; i++) {
      let call = callSequence[i];
      const [actionId, type] = call.split('_');
      const action = idToPos[actionId];
      type === undefined ? action.invoke = i : (action.resolve = i, action.status = type);
    }
  }

  function convertEdges(idToPos) {
    for (let i = 0, action; action = idToPos[i]; i++) {
      let {params, fun, result, error, id, pos, invoke, resolve, status} = action;
      action.params = params.map(p => {
        const optional = p[0] === '*';
        const state = optional ? p.substr(1) : p;
        return {state, xy: idToPos[state].pos, xy2: pos, action: id, optional, invoke}
      });
      action.result = {state: result, xy: pos, xy2: idToPos[result].pos, action: id};
      action.error = {state: error, xy: pos, xy2: idToPos[error].pos, action: id};
      if (status.indexOf('e') >= 0) {
        action.error.resolve = resolve;
        action.error.status = status;
      } else {
        action.result.resolve = resolve;
        action.result.status = status;
      }
    }
  }

  function computeOM(hash) {
    let [actions, callSequence] = Array.from(hashToObj(hash));
    const mainTable = stateActionSequence(
      actions.map(([params, fun, result, error], id) => ({params, fun, result, error, id})),
      stateNames(actions)
    );

    const [idToPos, unit] = addCoordinatesIdKeyAndCalcUnit(mainTable);
    actionToCallSequence(idToPos, callSequence);
    convertEdges(idToPos);
    return [idToPos, unit];
  }

  //todo printer
  //todo printer
  //todo printer
  function printCoordinate([x, y], xy2) {
    let pos = `--x: ${x}; --y: ${y};`;
    if (xy2 === undefined)
      return pos;
    const [x2, y2] = xy2;
    const angle = Math.floor(Math.atan2(y2 - y, x2 - x) * 180 / Math.PI);
    const diagonal = Math.sqrt(Math.pow((x2 - x), 2) + Math.pow((y2 - y), 2));
    return pos + ` --angle: ${angle}deg; --diagonal: ${diagonal};`;
  }

  function makeElement(unit) {
    const div = document.createElement('div');
    div.innerText = unit.fun || unit.id;
    div.id = unit.id;
    div.style.cssText = printCoordinate(unit.pos);
    div.setAttribute('resolve', unit.resolve);
    div.setAttribute('invoke', unit.invoke);
    div.setAttribute('status', unit.status);
    div.classList.add('fun' in unit ? 'action' : 'state');
    if (!unit.result)
      return [div];
    const result = makeElementEdge('output', unit.result);
    const error = makeElementEdge('error', unit.error);
    const params = unit.params.map(p => makeElementEdge('input', p));
    return [div, ...params, result, error];
  }

  function makeElementEdge(type, {optional, xy, xy2, resolve, status, invoke}) {
    const div = document.createElement('div');
    optional && (div.innerText += '*');
    div.style.cssText = printCoordinate(xy, xy2);
    div.classList.add(type);
    resolve && div.setAttribute('resolve', resolve);
    invoke && div.setAttribute('invoke', invoke);
    status && div.setAttribute('status', status);
    return div;
  }

  function render([idToPos, unit]) {
    document.styleSheets[0].insertRule(`:root{ --unit: ${Math.floor(100 / (unit + 1))}%}`)
    const mainDiv = document.querySelector('div');
    Object.values(idToPos).map(unit => makeElement(unit, idToPos)).flat(1).forEach(el => mainDiv.append(el));
  }

  render(computeOM(location.hash.substr(1)));
  window.addEventListener('hashchange', e => location.hash && render(computeOM(location.hash.substr(1))));
</script>

<script>
  let test = `[[[[request],,a,a],[[request],,a,response],[[request],maybeError,hello,maybeError],[[maybeError],maybeErrorHandler,error,_error3],[[request],helloSunshine,response,_error4],[[error],errorToResult,response,response],[[response,*hello],log,_observer6,_error6]],[0,0_s,1_c,2,2_se,3,3_s,4,5,5_s,6,4_ba,6_sa]]`;
  location.hash = test;
</script>
1. Make main table.
A. List all state names and duplicate actions list.
B. Iterate the state names. Move all state names to next row in main table that is not an output state of any of the actions.
C. Iterate the actions duplicate. Move all actions to the next row in the main table that has no input that is listed in the states list.
Repeat B and C until empty state and duplicate actions lists.
D. Convert the main table into a map: state name/actionid =>[x, y].

3. Iterate actions list to make inputEdgeList.
A. For each input, make an entry with [actionid, state name, state koordinate, action koordinate].

5 and 7. Do the same as inputEdgeList, except for result and error.